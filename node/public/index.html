<html>
    <head>
        <!-- <link rel="stylesheet" href="index.css"> -->

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/codemirror.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/codemirror.min.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/theme/material-darker.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/mode/javascript/javascript.min.js"></script>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/hint/show-hint.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/hint/javascript-hint.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/hint/show-hint.min.css">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/scroll/simplescrollbars.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/scroll/simplescrollbars.min.css">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/comment/comment.min.js"></script>
        <style>
body
{
  background: black;
  color: #bbb;
  font-family: Roboto, Arial, sans-serif;
  margin: 0;
}
input
{
  color: #bbb;
  background: #333;
}
input:focus
{
  outline: none;
}
a, .link
{
  /*color: #8d8;*/
  text-decoration: none;
  cursor: pointer;
  color: #bbb;
  text-decoration-line: underline;
  text-decoration-color: #ffffff22;
}
h1 small
{
  color: #333;
  font-size: 0.5em;
}
/*a:hover, .link:hover
{
  text-decoration: underline;
}*/


  ::-webkit-scrollbar {
    width: 10px;
  }
  ::-webkit-scrollbar-track {
    background:  #ffffff22; 
    border-radius: 5px;
  }
  ::-webkit-scrollbar-thumb {
    background:  #ffffff44; 
    border-radius: 5px;
  }



#app
{
  display: flex;
  flex-direction: row;
}
#app > .left
{
  flex: 8;
  padding: 8px;
}
#app > .right
{
  flex: 2;
  border-left: solid 3px #222;
  padding: 8px;
  display: none;
}

#selectedDescriptor
{
  margin-top: 3em;
}

.items
{
  display: grid;
  grid-template-columns: auto auto auto;
  grid-column-gap: 10px;
  grid-row-gap: 10px;
}

.items > div
{
    /*width: 100%;*/
  /*padding-bottom: 70%;*/
  height: 17em;
}
.items img
{
  object-fit: cover;
  width: 100%;
  height: 14em;  
}

:root {
  --youtube-row-unit: 1em;
}

.rowView
{
  display: flex;
  flex-direction: row;
  padding: calc(var(--youtube-row-unit)/4);
}
.youtube.rowView img
{
  object-fit: cover;
  width:        calc(var(--youtube-row-unit)*8);
  height:       calc(var(--youtube-row-unit)*4*1.1);
  margin-right: calc(var(--youtube-row-unit)/4);
}
.youtube.rowView > div
{
  margin: calc(var(--youtube-row-unit)/4);
}
.rowView .title
{
  font-weight: bold;
  margin-bottom: calc(var(--youtube-row-unit)/4);
}
.rowView .tags, .rowView .subtitle, .rowView .watching
{
  font-size: 0.8em;
}

#header
{
  display: flex;
  flex-direction: row;
  align-items: center;
}
#header form
{
  margin: 0;
}

#headerSearch
{
  background: #222;
  width: min(70vw, 50em);
  margin: 0.4em;
  padding: 0 0.8em;
  height: 2.3em;
  border: 0;
  border-radius: 0.2em;
}

#searchResults
{
  position: relative;
}
#searchResultsContainer
{
  position: absolute;
  background: #111;
  padding: 0.8em;
  border-radius: 0.4em;
  min-width: 70vw;
  visibility: hidden;
}


.CodeMirror-overlayscroll-horizontal div, .CodeMirror-overlayscroll-vertical div
{
  background: #ffffff33;
}



@keyframes fadeOut {
    from {opacity: 1;}
    to {opacity: 0;display:none;}
}
#toastMessage
{
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  /*height: 1em;*/
  background: #222;
  /*animation: fadeOut 1s forwards;*/
  padding: 1em;
  text-align: center;
  opacity: 0;
}
#toastMessage.showing
{  
  transition: all 0.1s linear;
  opacity: 1;
}
#toastMessage.hidding
{  
  transition: all 0.3s linear;
  opacity: 0;
}
#toastMessage.hidden
{  
  display: none; 
}

.collection-items > div
{
  display: flex;
  flex-direction: row;
}
.collection-items > div > .shortcut
{
  width: 2em;
  font-size: 0.7em;
  color: #333;
  display: flex;
  align-items: center;
  justify-content: center; 
}




        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js" type="text/javascript"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.25.0/moment.min.js" type="text/javascript"></script>
        <script src="https://cdn.jsdelivr.net/npm/minisearch@2.2.0/dist/umd/index.min.js"></script>
        <script src="https://unpkg.com/idb@5.0.2/build/iife/index-min.js"></script>
        <script>var require=()=>{};var module={};</script>
        <script src="core.js" type="text/javascript"></script>
    </head>
    <body>

<div id="app">
    <div class="left">
      <div id="header">
        <a href="#kaisHome">[h]</a>
        <span class="link" onclick="addToClipboard()">[b]</span>
        <div>
          <form onsubmit="onHeaderSearch()"><input type="text" id="headerSearch" oninput="onHeaderSearchChanged()" autocomplete="off" /></form>
          <div id="searchResults"><div id="searchResultsContainer"></div></div>
        </div>
      </div>
      <div id="content"></div>
      <div id="selectedDescriptor"></div>
      <textarea id="codeEditor"></textarea>
    </div>
    <div class="right">
      <div id="sideContent"></div>
  </div>
  <div id="toastMessage" class="hidden"></div>
</div>

<script>
var wait = ms => new Promise((r, j)=>setTimeout(r, ms))
var resolvablePromise = () =>
{
  var resolve,reject;
  var associate = (r, j)=>{resolve = r;reject = j}
  var promise = new Promise(associate);
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
}
function findParent(tagname,el){
  while (el){
    if ((el.nodeName || el.tagName).toLowerCase()===tagname.toLowerCase()){
      return el;
    }
    el = el.parentNode;
  }
  return null;
}

function htmlToElement(html) {
    var template = document.createElement('template');
    if(!html) html = '</span>undefinedHtml</span>';
    html = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = html;
    return template.content.firstChild;
}



var toastMessageEl = document.getElementById('toastMessage');
var showToast = async(content)=>
{
  console.log("showToast()",content);
  toastMessageEl.innerHTML = content;
  toastMessageEl.classList.remove('hidden');
  await wait(0);
  toastMessageEl.classList.add('showing');
  await wait(2000);
  toastMessageEl.classList.add('hidding');
  await wait(302);
  toastMessageEl.classList.add('hidden');
  await wait(0);
  toastMessageEl.classList.remove('hidding');
  toastMessageEl.classList.remove('showing');
}






var claimsDB;
async function openClaimsDB()
{
  claimsDB = await idb.openDB("claims", 1, {
    upgrade(db, oldVersion, newVersion, transaction) {
      db.createObjectStore('claims', { keyPath: 'id' });
    },
  });

}


var persistedCount = 0;
function reportPersistedNow()
{
  console.log("reportPersistedNow()","persisted",persistedCount,"claims");
  persistedCount = 0;
}
var reportPersistedDebounced = _.throttle(reportPersistedNow,5000);
function reportPersisted()
{
  persistedCount++;
  reportPersistedDebounced();
}

async function persistClaim(claim)
{
  var claimJson = claim.toCompactJson();
  claimJson.id = claim.id;
  await claimsDB.put('claims', claimJson);
  reportPersisted();
  // console.log("persistClaim()","claim",claim.id,claim.idStr,"persisted");
}

// Claim.onNewClaim = persistClaim;
var _skipPersistLocal = false;
var _skipPersistServer = false;
Claim.onNewClaim = claim=>
{
  if(!_skipPersistLocal) console.log("Claim.onNewClaim()","claim",claim.id,claim.idStr,"persistClaim()");
  if(!_skipPersistLocal) persistClaim(claim);
  if(!_skipPersistServer) console.log("Claim.onNewClaim()","claim",claim.id,claim.idStr,"sendClaimToServer()");
  if(!_skipPersistServer) sendClaimToServer(claim);
};

async function loadClaimsForDB()
{
  _skipPersistServer = true;
  _skipPersistLocal = true;
  console.log("loadClaimsForDB()","_skipPersistLocal",_skipPersistLocal);
  var claimJsons = await claimsDB.getAll('claims')
  for(var claimJson of claimJsons)
    var claim = Claim.fromCompactJson(claimJson);
  _skipPersistLocal = false;
  _skipPersistServer = false;
  console.log("loadClaimsForDB()","_skipPersistLocal",_skipPersistLocal);
}







async function importData(jsonPath)
{
  _skipPersistServer = true;
  var fetched = await fetch(jsonPath);
  var json = await fetched.json();
  importClaims(json.compactJson);
  _skipPersistServer = false;

}




var loggedUser;
var socket;
var _wsRequestPromises = {};
var connectToWebsocket = ()=>
{
  socket = new WebSocket('ws://localhost:8080');
  // Connection opened
  socket.addEventListener('open', function (event)
  {
  });
  socket.addEventListener('close', async function (event)
  {
    // alert("WebSocket closed.");
    await wait(1000);
    connectToWebsocket();
  });

  socket.addEventListener('message', function (event)
  {
    // console.log('Message from server ', event.data);
    var json = JSON.parse(event.data);
    _wsRequestPromises[json.requestId].resolve(json);
  });
}
connectToWebsocket();


async function wsFetch(request)
{
  if(_claimsToServerStore)
  {
    _sendClaimsToServerDebounced.cancel();
    if(!request.claims)
    {
      var claimsRequest = _sendClaimsToServerNow(true);
      request.claims = claimsRequest.claims;
    }
    else _sendClaimsToServerNow();
  }

  request.requestId = randHex();
  var promise = resolvablePromise();
  _wsRequestPromises[request.requestId] = promise;
  socket.send(JSON.stringify(request));
  var response = await promise;
  _skipPersistServer = true;
  if(response.claims) importClaims(response.claims);
  _skipPersistServer = false;
  delete _wsRequestPromises[request.requestId];
  return response;
}




var _claimsToServerStore;
function _sendClaimsToServerNow(_getRequestNotSent=false)
{
  console.log("sendClaimsToServerNow()","claim count",_claimsToServerStore.length);
  var compactJson = _claimsToServerStore.toCompactJson();
  _claimsToServerStore = null;
  var request = {claims:compactJson};
  if(_getRequestNotSent) return request;
  wsFetch(request); // ignore the answer, assumes it went through
}
_sendClaimsToServerDebounced = _.debounce(_sendClaimsToServerNow,500,{maxWait:3000});

function sendClaimToServer(claim)
{
  if(!_claimsToServerStore) _claimsToServerStore = new ClaimStore();
  _claimsToServerStore.addClaim(claim);
  _sendClaimsToServerDebounced();
}


async function fectchComplementaryNodesFromServer(nodes)
{
  var unknownNodes = [];
  nodes.forEach(node=>
  {
    var types = node.getFrom_types();
    types.forEach(type=>
    {
      if(!type.$(_instanceOf)) unknownNodes.push(type);
      node.typeTos[type.id].forEach(claim=>
      {
        var to = claim.to;
        if(to instanceof Node && !to.$(_instanceOf)) unknownNodes.push(to);
      });
    });
  });
  if(unknownNodes.length > 0) console.log("fectchComplementaryNodesFromServer() …",'count',nodes.length,'unknownCount',unknownNodes.length);
  if(unknownNodes.length > 0) await fetchNodesFromServer(unknownNodes);
}

async function fetchNodesFromServer(nodes)
{
  await wsFetch({request:"fetchNodesById",nodeIds:nodes.map(n=>n.id)});
  console.log("fetchNodesByIdFromServer() done. Nodes: ",nodes.map(n=>n.$('prettyString')));
  await fectchComplementaryNodesFromServer(nodes);
}

// async function fetchCollectionFromServer(collection,skip=0,limit=10)
// {
//   var {results,totalCount} = await wsFetch({request:"fetchCollection",collection:$$(collection).id,skip,limit});
//   results = results.map(id=>Node.makeById(id));
//   await fectchComplementaryNodesFromServer(results);
//   return {results,totalCount};
// }


async function serverFetchCollection(collection,skip=0,limit=10,localIds=[])
{
  console.log("serverFetchCollection()",skip.from ? 'from: '+skip.from.$('prettyString') : skip,limit);

  // TODO make sure that the server has skip.from (send proactively if in doubt, just in case,
  // or if unlikely, leave it ask for it if needed).
  if(skip.from) skip.from = skip.from.id;
  // results contains only nodes not in localIds
  var {results,totalCount} = await wsFetch({request:"fetchCollection",collection:$$(collection).id,skip,limit,localIds});
  results = results.map(id=>Node.makeById(id));
  await fectchComplementaryNodesFromServer(results);
  return {results,totalCount};
}
















async function onHeaderSearch()
{
  var input = document.getElementById('headerSearch').value;
  var youtubeVideoUrlRegex = /https:\/\/www.youtube.com\/watch\?v=([a-zA-Z0-9\-]+)/;
  var youtubeVideoUrlMatch = input.match(youtubeVideoUrlRegex);
  if(youtubeVideoUrlMatch)
  {
    var vid = youtubeVideoUrlMatch[1];
    // var response = await wsFetch({multiple:false,descriptor:[["instanceOf","YoutubeVideo"],["strid",vid]]});
    var response = await wsFetch({request:"makeYouTubeVideo",vid});
    goToObject(response.videoId);
  }
  document.getElementById('headerSearch').value = '';
}
var searchResultsContainer = document.getElementById('searchResultsContainer');
var searchInput = document.getElementById('headerSearch');
async function onHeaderSearchChanged()
{
  searchResultsContainer.innerHTML = '';
  var results = fulltextSearch.search(searchInput.value);
  if(results.length > 25) results = results.slice(0,25);
  results = results.map(({id})=>$$(id));

  results.forEach(result=>
  {
    searchResultsContainer.appendChild(htmlToElement(result.$('rowView')));
  });

  searchResultsContainer.style.visibility = results.length > 0 ? "visible" : "hidden";
}

function clearHeaderSearch()
{
  // if(searchInput === document.activeElement)
  var needed = searchResultsContainer.style.visibility == 'visible'
    || searchInput.value != '';

  searchResultsContainer.style.visibility = "hidden";
  searchInput.value = '';

  return needed;
}









// const CollectionShortcuts = "0123456789abcdefghijklmnopqrstuvwxyz";
document.addEventListener('keydown', (e) => {
  
  var c = e.ctrlKey;
  var s = e.shiftKey;
  // console.log("keydown",e.key,e.ctrlKey);
  if(myCodeMirror.hasFocus())
  {
    if(!c&&!s&& e.key == 'Escape')
    {
      console.log("escaping editor…","myCodeMirrorUnsaved",myCodeMirrorUnsaved);
      if(!myCodeMirrorUnsaved || confirm("There are unsaved change. Exit editor anyway?"))
        myCodeMirrorElStyle.visibility = "hidden";
      return e.preventDefault();
    }
    if( c&&!s&& (e.key == 's' || e.key == 't'))
    {
      console.log("saving…");
      saveEditJs();
      myCodeMirrorUnsaved = false;
      if(e.key == 't') myCodeMirrorElStyle.visibility = "hidden";
      return e.preventDefault();
    }
  }
  else
  if(searchInput !== document.activeElement)
  {
    if( c&& s&& e.key == 'e')
    {
      myCodeMirrorElStyle.visibility = "visible";
      return e.preventDefault();
    }


    if(!c&&!s&& e.key == 'a')
    {
      window.history.back();
      return e.preventDefault();
    }
    if(!c&&!s&& e.key == 'e')
    {
      window.history.forward();
      return e.preventDefault();
    }


    // if(e.ctrlKey)
    // {
    //   var pos = CollectionShortcuts.indexOf(e.key);
    //   var collection = document.getElementsByClassName('collection-items')[0];
    //   console.log("shift+shortcut",e.key,pos,collection);
    //   if(pos != -1 && collection)
    //   {
    //     var child = collection.children[pos]; // should search by data-shortcut attribute
    //     console.log("shift+shortcut",pos,collection,child);
    //     if(child)
    //     {
    //       var node = $$(child.dataset.node);
    //       showObject(node);
    //       return e.preventDefault();
    //     }
    //   }
    // }

  }
});



document.addEventListener('keyup', (e) => {
  
  var c = e.ctrlKey;
  var s = e.shiftKey;

  // console.log("keyup",e.key,e.ctrlKey);
  if(myCodeMirror.hasFocus())
  {
    return;
  }

  if(!c&&!s&& e.key == 'Escape')
  {
    clearHeaderSearch();
  }
  if(searchInput !== document.activeElement)
  {
    if(!c&&!s&& e.key == 'v')
    {
      var defaultMethod = selectedNode.$ex('object.defaultPageView');
      if(selectedMethod != defaultMethod)
        goToObject(selectedNode);
      else if(selectedMethod != 'simpleView')
        goToObject(selectedNode,'simpleView');
        // window.location.hash = selectedNode.name+'/simpleView';
      return e.preventDefault();
    }
    if(!c&&!s&& e.key == 'i')
    {
      var instanciable = selectedNode.$('instanceOf');
      if(instanciable) goToObject(instanciable);
      return e.preventDefault();
    }
    if(!c&&!s&& e.key == 'b')
    {
      addToClipboard();
      return e.preventDefault();
    }

    if(!c&&!s&& e.key == 'c')
    {
      if(selectedNode.$('instanceOf') == $$('collection'))
      {
        var mainContainingNode = selectedNode.$('mainContainingNode');
        if(mainContainingNode) goToObject(mainContainingNode);
      }
      else
      {
        var collection = selectedNode.$('collection');
        if(collection) goToObject(collection);
      }
      return e.preventDefault();
    }

    var menu = document.getElementsByClassName("menu")[0];
    // console.log(menu instanceof Element);
    // console.log(menu);
    var options = menu && menu.getElementsByClassName("option");
    options = options && Array.prototype.slice.call(options) || [];
    // console.log(options);

    options = options && options.map(option=>
      {
        var links = option.getElementsByTagName('a');
        var link = links && links[0];
        // console.log(link);
        // console.log(link.href);
        return link && link.href;
      });

    if(!c&&!s&& e.key == '.')               location.hash = "kaisHome";
    if(!c&&!s&& e.key == '0' && options[0]) window.location.href = options[0];
    // else if(e.key == '0')          location.hash = "kaisHome";
    // if(e.key == '0'              ) location.hash = "kaisHome";
    // if(e.key == '9' && options[0]) location.hash = options[0].substring(1);
    // if(e.key == '6' && options[1]) location.hash = options[1].substring(1);
    // if(e.key == '3' && options[2]) location.hash = options[2].substring(1);
    if(!c&&!s&& e.key == '1' && options[1]) window.location.href = options[1];
    if(!c&&!s&& e.key == '2' && options[2]) window.location.href = options[2];
    if(!c&&!s&& e.key == '3' && options[3]) window.location.href = options[3];
  }
});




document.addEventListener("click", async e=>
{
  var aEl = findParent('a',e.target || e.srcElement);
  if (!aEl) return;
  var url = aEl.href;
  var hash = url.split('#');
  if(hash.length == 0) return;
  hash = _.last(hash);
  if(hash.includes('/')) return; // TODO, maybe
  var node = $$(hash);
  if(!node) console.error("on click,","unknown node",hash);
  if(!node) return;
  if(e.shiftKey)
  {
    addToClipboard(node);
    e.preventDefault();
    e.stopPropagation();
    clearHeaderSearch();
    return;
  }

  if(selectedMethod != 'simpleView'
    || searchResultsContainer.style.visibility == "visible")
  {
    var instanciable = node.$('instanceOf');
    if(instanciable && instanciable == $$('tag'))
    {
      var descriptor = makeUnique([
          ['object.instanceOf','descriptorFrom'],
          ['descriptorFrom.to',node],
          ['descriptorFrom.type','object.tags'],
        ])
      var collection = makeUnique([
          ['object.instanceOf','collection'],
          ['collection.descriptor',descriptor],
        ])
      e.preventDefault();
      e.stopPropagation();
      goToObject(collection);
    }
    if(instanciable && instanciable == $$('YoutubeChannel'))
    {
      var descriptor = makeUnique([
          ['object.instanceOf','descriptorFrom'],
          ['descriptorFrom.to',node],
          ['descriptorFrom.type','YoutubeVideo.channel'],
        ])
      var collection = makeUnique([
          ['object.instanceOf','collection'],
          ['collection.descriptor',descriptor],
        ])
      e.preventDefault();
      e.stopPropagation();
      goToObject(collection);
    }
  }
  console.log("clicked",url);
});

// content.appendChild(_instanciable.executeJsMethod($$('simpleView')));





























var viewport = ()=>
{
  if(window.visualViewport) return window.visualViewport;
  return {width:window.innerWidth,height:window.innerHeight};
}

window.onscroll = function()
{
  var contentBox = document.body.getBoundingClientRect()
  var bottomPos = document.body.scrollTop+viewport().height;
  // console.log(document.body.scrollTop,contentBox.height,viewport().height,bottomPos>contentBox.height-500);
  if(bottomPos>contentBox.height-500 && !loadingPagination)
    pageCollection();
};




function addToClipboard(node)
{
  if(!node) node = selectedNode;
  loggedUser.$('clipboard',node);
  showToast("clipboarded "+node.$('prettyString'));
}

var collectionPagingInfo;
var loadingPagination = false;
async function pageCollection()
{
  loadingPagination = true;
  if(selectedInstanciable != $$('collection'))
  {
    collectionPagingInfo = undefined;
    return;
  }
  var node = selectedNode;

  if(!collectionPagingInfo || collectionPagingInfo.collection != node)
    collectionPagingInfo = {collection:node,skip:0,count:0};
  if(!collectionPagingInfo.reachedEnd)
  {
    var limit = 50;
    var results = await node.$exAsync('fetch',collectionPagingInfo.skip,limit);
    // results.forEach(r=>console.log("pageCollection() PAGING",r.id,r.$('prettyString')));

    // TODO wait that the page is rendered
    var collectionContainer = document.getElementsByClassName('collection-items')[0];
    // console.log('pageCollection()',collectionContainer);
    if(!collectionContainer) console.error("pageCollection()","collectionContainer not found on DOM.");
    else results.forEach(r=>
    {
      console.log("pageCollection() adding to DOM: ",r.id,r.$('prettyString'));
      collectionContainer.appendChild(htmlToElement(  r.$ex('rowView')  ));
    });

    collectionPagingInfo.count+= results.length;
    if(results.length < limit) console.log("pageCollection() PAGING REACHED END")
    if(results.length < limit) collectionPagingInfo.reachedEnd = true;
    // if(results.length == 0) collectionPagingInfo.reachedEnd = true;
    else collectionPagingInfo.skip = {from:_.last(results)};
    // await showObject(selectedNode,false,true);
  }

  // if(!collectionPagingInfo || collectionPagingInfo.collection != node)
  //   collectionPagingInfo = {collection:node};
  // var c = collectionPagingInfo;
  // if(c.serverTotalCount == undefined || c.serverSkip < c.serverTotalCount)
  // {
  //   var {totalCount,results} = await fetchCollectionFromServer(node,c.serverSkip,50);
  //   c.serverTotalCount = totalCount;
  //   c.serverSkip = (c.serverSkip || 0)+results.length;
  //   console.log('pageCollection',results.map(r=>r.$('prettyString')),c);
  //   // if(c.serverSkip < c.serverTotalCount)
  //   await showObject(selectedNode,false,true);
  // }
  loadingPagination = false;
}
var goToObject = async (node,method=undefined)=>
{
  node = $$(node);
  var hash = node.name;
  var defaultMethod = node.$ex('object.defaultPageView');
  if(!method) method = defaultMethod;
  if(method != defaultMethod)
    hash+= '/'+method;
  location.hash = hash;
}

var _content = document.getElementById("content");
var selectedNode = _instanciable;
var selectedInstanciable = _instanciable;
var selectedMethod;
var showObject = async (node,updateHash=true,paginating=false)=>
{
  clearHeaderSearch();

  // var method = 'object.simpleView';
  selectedMethod = undefined;
  if(!node) node = selectedNode;
  if(_.isString(node)) 
  {
    var split = node.split('/');
    if(split.length >= 2)
    {
      node = split[0];
      selectedMethod = split[1];
    }
    node = resolveIntoNode(node);
  }
  if(!node) node = selectedNode;
  selectedNode = node;
  var hash = node.name;
  var instanciable = node.$('instanceOf');
  selectedInstanciable = instanciable;

  // var defaultMethod = instanciable && instanciable.$('defaultPageView') || 'simpleView';
  // var defaultMethod2 = node.$('object.defaultPageView');
  var defaultMethod = node.$ex('object.defaultPageView');
  // if(defaultMethod2 != defaultMethod || defaultMethod3 != defaultMethod)
  //   console.error("showObject()",defaultMethod,defaultMethod2,defaultMethod3);
  if(!selectedMethod) selectedMethod = defaultMethod;
  if(selectedMethod != defaultMethod)
    hash+= '/'+selectedMethod;
  if(updateHash) location.hash = hash;
  var methodObject = strToType(selectedMethod,node);
  var html = methodObject && await node.$ex(methodObject);
  console.log("showObject()","LOAD",node.name,selectedMethod,'#'+hash,
    // "instanciable",instanciable&&instanciable.name,
    // 'defaultMethod2',defaultMethod2,
    "method",methodObject&&methodObject.name);
  // console.log("showObject()","LOAD",html);
  _content.innerHTML = '';

  // if(!method.includes('.')) method = '.'+method;
  // _content.appendChild(htmlToElement(  await Promise.resolve( $$(node,method) )  ));
  document.title = node.$('prettyString')+(instanciable?' • '+instanciable.$('prettyString'):'')+' • Public';
  _content.appendChild(htmlToElement(  html  ));
  if(!paginating)
  {
    // should trigger pageCollection()
    if(document.body.scrollTop != 0) window.scrollTo({top:0});
    else pageCollection(node);
  }
  // await wait(0);
  // if(!paginating) pageCollection(node);
}

var _selectedDescriptor = document.getElementById("selectedDescriptor");
var selectedDescriptor;
var updateSelectedDescriptor = descriptor=>
{
  console.log("updateSelectedDescriptor()","descriptor",descriptor);
  _selectedDescriptor.innerHTML = '';
  _selectedDescriptor.appendChild(htmlToElement($$(descriptor,'object.htmlSmallDescription')));

  selectedDescriptor = descriptor;
}
var editStringDescriptor = descriptor=>
{
  // if(!confirm('Are you sure?')) return;
  var value = $$(descriptor,"descriptorTo.resolve");
  var newString = prompt("string value:", value&&value.s);
  if(newString === null) return;
  $$( $$(descriptor,"descriptorTo.from"),$$(descriptor,"descriptorTo.type"),{s:newString} );
  showObjectFromHash();
}
// var editBooleanDescriptor = (descriptor,value)=>
// {
//   console.log("editBooleanDescriptor",descriptor.$('prettyString'),valueToString(value));
//   descriptor.$ex('insert',value);
//   // $$( $$(descriptor,"descriptorTo.from"),$$(descriptor,"descriptorTo.type"),{s:newString} );
//   showObjectFromHash();
// }
var insertIntoDescriptor = (descriptor,value)=>
{
  if(!confirm('Are you sure?')) return;
  console.log("insertIntoDescriptor",descriptor.$('prettyString'),valueToString(value));
  descriptor.$ex('insert',value);
  showObjectFromHash();
}
var editJavascriptDescriptor = descriptor=>
{
  var value = descriptor.$("resolve");
  var jsStr = value && value.j && String(value.j) || "function()\n{\n  \n}";
  console.log('editJavascriptDescriptor()',descriptor.$('prettyString'),jsStr);
  // document.getElementById("codeEditor").innerHTML = jsStr;
  myCodeMirror.setValue(jsStr);
  myCodeMirrorElStyle.visibility = "visible";
  myCodeMirrorUnsaved = false;
  myCodeMirror.focus();
  myCodeMirrorDescriptor = descriptor;

  // $$( $$(descriptor,"descriptorTo.from"),$$(descriptor,"descriptorTo.type"),{s:newString} );
  // showObjectFromHash();
}

var createField = (type,instanciable)=>
{
  if(!confirm('Are you sure?')) return;
  var claimtype = $$()
    .$('object.instanceOf','claimType')
    .$('claimType.typeFrom',instanciable)
    .$('claimType.typeTo',type);
  console.log("createField",type.$('prettyString'),instanciable.$('prettyString'));
  goToObject(claimtype);
}

var saveEditJs = ()=>
{
  var js;
  try
  {
    js = eval('('+myCodeMirror.getValue()+')');
  }
  catch(e)
  {
    alert('could not compile js');
    console.error('saveEditJs()','could not compile js',e);
  }
  console.log('saveEditJs()',myCodeMirrorDescriptor.$('prettyString'),String(js));
  myCodeMirrorDescriptor.$ex('insert',{j:js});
}
var createInDescriptor = descriptor=>
{
  var instance = $$(descriptor,'descriptorFrom.instanciate');
  goToObject(instance);
}

var showObjectFromHash = ()=>showObject(location.hash && location.hash.substring(1) || "instanciable",false);




// async function fetchYoutubePlaylist(playlistId,results=[],pageToken=undefined)
// {
//   console.log("fetchYoutubePlaylist()","pageToken",pageToken);
//   var path = 'https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&key=AIzaSyByA7cXJD_3Hi8f2rTQ3loCyqIA6NfK9fc&playlistId='+playlistId+'&maxResults=50';
//   if(pageToken) path+= '&pageToken='+pageToken;
//   var fetched = await fetch(path);
//   var json = await fetched.json();
//   json.items.forEach(item=>
//   {
//     var vid = item.snippet.resourceId.videoId;
//     console.log("fetchYoutubePlaylist()","videoId",vid);
//     results.push(vid);
//     $$(vid).$(_instanceOf,"YoutubeVideo").$('YoutubeVideo.title',{s:item.snippet.title});
//   });
//   if(json.nextPageToken) await fetchYoutubePlaylist(playlistId,results,json.nextPageToken);
//   return results;
//   // console.log("json",json);
// }
// async function fetchYoutubePlaylists(channelId,results=[],pageToken=undefined)
// {
//   console.log("fetchYoutubePlaylists()","pageToken",pageToken);
//   var path = 'https://www.googleapis.com/youtube/v3/playlists?part=snippet&key=AIzaSyByA7cXJD_3Hi8f2rTQ3loCyqIA6NfK9fc&channelId='+channelId+'&maxResults=50';
//   if(pageToken) path+= '&pageToken='+pageToken;
//   var fetched = await fetch(path);
//   var json = await fetched.json();
//   json.items.forEach(item=>
//   {
//     var pid = item.id;
//     console.log("fetchYoutubePlaylists()","playlistId",pid);
//     results.push(pid);
//     $$(pid).$(_instanceOf,"YoutubePlaylist").$('YoutubePlaylist.title',{s:item.snippet.title});
//   });
//   if(json.nextPageToken) await fetchYoutubePlaylists(channelId,results,json.nextPageToken);
//   return results;
//   // console.log("json",json);
// }

// async function fetchYoutubeData(vid='IK7nBOLYzdE')
// {
//   var path = 'https://cors-anywhere.herokuapp.com/https://www.youtube.com/watch?v='+vid;
//   var fetched = await fetch(path);

//   var text = await fetched.text();
//   var match = text.match(/window\[\"ytInitialPlayerResponse\"\] = (.*)/);
//   if(!match) throw new Error('no json information found');

//   var json = match[1];
//   json = json.substring(0,json.length-1); // removes end ';'
//   json = JSON.parse(json);

//   // console.log('FOUND',json);
//   // console.log('FOUND',JSON.stringify(json,null,'    '));

//   var videoDetails = json.videoDetails;
//   var microformat = json.microformat;
//   var playerMicroformatRenderer = microformat.playerMicroformatRenderer;

//   var processedJson = {};
//   processedJson.fetchDate = new Date();
//   processedJson.title = videoDetails.title;
//   processedJson.lengthSeconds = Number(videoDetails.lengthSeconds);
//   processedJson.averageRating = videoDetails.averageRating;
//   processedJson.viewCount = Number(videoDetails.viewCount);
//   processedJson.publishDate = new Date(playerMicroformatRenderer.publishDate);
//   processedJson.uploadDate = new Date(playerMicroformatRenderer.uploadDate);
//   processedJson.description = playerMicroformatRenderer.description.simpleText;
//   processedJson.keywords = videoDetails.keywords;
//   processedJson.channelId = videoDetails.channelId;
//   processedJson.author = videoDetails.author;
//   processedJson.ownerChannelName = playerMicroformatRenderer.ownerChannelName;

//   var result = {};
//   result.sourceHtml = text;
//   result.extractedJson = json;
//   result.processedJson = processedJson;

//   return result;
// }



(async ()=>
{
  await openClaimsDB();
  await loadClaimsForDB();
  // var fetched = await fetch('https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=PLfoEg9YVcQQS14MaRPjRdYM_Y-HwoQFPJ&key=AIzaSyByA7cXJD_3Hi8f2rTQ3loCyqIA6NfK9fc&pageToken=CAUQAQ&maxResults=5');
  // var json = await fetched.json();
  // console.log("json",json);

  console.log("Claims loaded from local indexedDB.");

  // in the background
  // importData('http://localhost:3000/all');
  // TODO await if db not initiated (can test .count() < 100)
  await importData('http://localhost:3000/all');
  console.log("Claims loaded from server.");

  loggedUser = $$('person').$froms('instanceOf').find(u=>u.$('title') == 'Kai Elvin');
  console.log("loggedUser",loggedUser&&loggedUser.$('title'));

  // var playlist = await fetchYoutubePlaylists('UCDDe2Yh15Yj4ljU_2f311mQ');
  // fetchYoutubePlaylist('PLfoEg9YVcQQS14MaRPjRdYM_Y-HwoQFPJ');

  window.addEventListener("hashchange", showObjectFromHash);
  showObjectFromHash();

  // var request = indexedDB.open("library");

  console.log(JSON.stringify(Claim.comb));
  console.log(_.sum(Claim.comb));

  // fetchYoutubeData('xWggTb45brM');
  // const items = await indexedDB.transaction('testStore').objectStore('testStore').getAll()
}
)();




var myCodeMirror = CodeMirror.fromTextArea(document.getElementById("codeEditor"), {
  // value: "function myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\nfunction myScript(){return 100;}\n",
  mode:  "javascript",
  extraKeys: {"Ctrl-Space": "autocomplete",
              "Ctrl-/": "toggleComment",
            },
  lineWrapping: true,
  lineNumbers: true,
  // autofocus: true,
  cursorScrollMargin: 2, // doesn't seem to work
  spellcheck: true,
  autocorrect: true,
  theme: "material-darker",
  scrollbarStyle: "overlay",
});

var myCodeMirrorUnsaved = false;
myCodeMirror.on('change',()=> myCodeMirrorUnsaved = true);



var myCodeMirrorElStyle = myCodeMirror.getWrapperElement().style;
myCodeMirrorElStyle.visibility = "hidden";
myCodeMirrorElStyle.position = "fixed";
myCodeMirrorElStyle.height = "auto";
myCodeMirrorElStyle.left = "10px";
myCodeMirrorElStyle.right = "10px";
myCodeMirrorElStyle.top = "50px";
myCodeMirrorElStyle.bottom = "50px";
var myCodeMirrorDescriptor;

</script>


    </body>
</html>