<html>
    <head>
        <!-- <link rel="stylesheet" href="index.css"> -->

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/codemirror.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/codemirror.min.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/theme/material-darker.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/mode/javascript/javascript.min.js"></script>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/hint/show-hint.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/hint/javascript-hint.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/hint/show-hint.min.css">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/scroll/simplescrollbars.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/scroll/simplescrollbars.min.css">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.50.2/addon/comment/comment.min.js"></script>
        <style>
body
{
  background: black;
  color: #bbb;
  font-family: Roboto, Arial, sans-serif;
  margin: 0;
}
input
{
  color: #bbb;
  background: #333;
}
input:focus
{
  outline: none;
}
a, .link
{
  /*color: #8d8;*/
  text-decoration: none;
  cursor: pointer;
  color: #bbb;
  text-decoration-line: underline;
  text-decoration-color: #ffffff22;
}
h1 small
{
  color: #333;
  font-size: 0.5em;
}
/*a:hover, .link:hover
{
  text-decoration: underline;
}*/


  ::-webkit-scrollbar {
    width: 10px;
  }
  ::-webkit-scrollbar-track {
    background:  #ffffff22; 
    border-radius: 5px;
  }
  ::-webkit-scrollbar-thumb {
    background:  #ffffff44; 
    border-radius: 5px;
  }



#app
{
  display: flex;
  flex-direction: row;
}
#app > .left
{
  flex: 8;
  padding: 8px;
}
#app > .right
{
  flex: 2;
  border-left: solid 3px #222;
  padding: 8px;
  display: none;
}

/*#selectedDescriptor
{
  margin-top: 3em;
}
*/
.items
{
  display: grid;
  grid-template-columns: auto auto auto;
  grid-column-gap: 10px;
  grid-row-gap: 10px;
}

.items > div
{
    /*width: 100%;*/
  /*padding-bottom: 70%;*/
  height: 17em;
}
.items img
{
  object-fit: cover;
  width: 100%;
  height: 14em;  
}

:root {
  --youtube-row-unit: 1em;
}

.rowView
{
  display: flex;
  flex-direction: row;
  padding: calc(var(--youtube-row-unit)/4);
}
.youtube.rowView img
{
  object-fit: cover;
  width:        calc(var(--youtube-row-unit)*8);
  height:       calc(var(--youtube-row-unit)*4*1.1);
  margin-right: calc(var(--youtube-row-unit)/4);
}
.youtube.rowView > div
{
  margin: calc(var(--youtube-row-unit)/4);
}
.rowView .title
{
  font-weight: bold;
  margin-bottom: calc(var(--youtube-row-unit)/4);
}
.rowView .tags, .rowView .subtitle, .rowView .watching
{
  font-size: 0.8em;
}

#header
{
  display: flex;
  flex-direction: row;
  align-items: center;
}
#header form
{
  margin: 0;
}

#headerSearch
{
  background: #222;
  width: min(70vw, 50em);
  margin: 0.4em;
  padding: 0 0.8em;
  height: 2.3em;
  border: 0;
  border-radius: 0.2em;
}

#searchResults
{
  position: relative;
}
#searchResultsContainer
{
  position: absolute;
  background: #111;
  padding: 0.8em;
  border-radius: 0.4em;
  min-width: 70vw;
  visibility: hidden;
}


.CodeMirror-overlayscroll-horizontal div, .CodeMirror-overlayscroll-vertical div
{
  background: #ffffff33;
}



@keyframes fadeOut {
    from {opacity: 1;}
    to {opacity: 0;display:none;}
}
#toastMessage
{
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  /*height: 1em;*/
  background: #222;
  /*animation: fadeOut 1s forwards;*/
  padding: 1em;
  text-align: center;
  opacity: 0;
}
#toastMessage.showing
{  
  transition: all 0.1s linear;
  opacity: 1;
}
#toastMessage.hidding
{  
  transition: all 0.3s linear;
  opacity: 0;
}
#toastMessage.hidden
{  
  display: none; 
}

.collection-items > div
{
  display: flex;
  flex-direction: row;
}


.dom-shortcut
{
  display: flex;
  flex-direction: row;
}
.collection-items > div > .shortcut, .dom-shortcut-id
{
  width: 2em;
  font-size: 0.7em;
  color: #333;
  display: flex;
  align-items: center;
  justify-content: center; 
}

.node-link
{
  position: relative;
}
.node-link-shortcut
{
  display: block;
  position: absolute;
  font-weight: normal;
  top: -0.5em;
  /*right: -1.3rem;*/
  opacity: 0.7;
  left: -1.3rem;
  font-size: 0.8rem;
  color: #fff;
  background: #333;
  /*padding: 0.2rem;*/
  width: 1rem;
  height: 1.2rem;
  border-radius: 0.3rem;
  text-align: center;
  line-height: 1.2rem;
  z-index: 1;
}



        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js" type="text/javascript"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.25.0/moment.min.js" type="text/javascript"></script>
        <script src="https://cdn.jsdelivr.net/npm/minisearch@2.2.0/dist/umd/index.min.js"></script>
        <script src="https://unpkg.com/idb@5.0.2/build/iife/index-min.js"></script>
        <script>var require=()=>{};var module={};</script>
        <script src="core.js" type="text/javascript"></script>
    </head>
    <body>

<div id="app">
    <div class="left">
      <div id="header">
        <!-- <a href="#kaisHome">[h]</a> -->
        <!-- <span class="link" onclick="addToClipboard()">[b]</span> -->
        <div>
          <form onsubmit="onHeaderSearch()"><input type="text" id="headerSearch" oninput="onHeaderSearchChanged()" autocomplete="off" /></form>
          <div id="searchResults"><div id="searchResultsContainer"></div></div>
        </div>
      </div>
      <div id="content"></div>
      <!-- <div id="selectedDescriptor"></div> -->
      <textarea id="codeEditor"></textarea>
    </div>
    <div class="right">
      <div id="sideContent"></div>
  </div>
  <div id="toastMessage" class="hidden"></div>
</div>

<script>
const WebClient = true;
const ServerSide = false;

var wait = ms => new Promise((r, j)=>setTimeout(r, ms))
var resolvablePromise = () =>
{
  var resolve,reject;
  var associate = (r, j)=>{resolve = r;reject = j}
  var promise = new Promise(associate);
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
}
function findParent(tagname,el){
  while (el){
    if ((el.nodeName || el.tagName).toLowerCase()===tagname.toLowerCase()){
      return el;
    }
    el = el.parentNode;
  }
  return null;
}

function htmlToElement(html) {
    var template = document.createElement('template');
    if(!html) html = '</span>undefinedHtml</span>';
    html = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = html;
    return template.content.firstChild;
}
function isVisible(elm) {
  var rect = elm.getBoundingClientRect();
  // var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
  var viewHeight = window.innerHeight;
  // console.log("isVisible()","rect.bottom",rect.bottom,"viewHeight",viewHeight);
  return !(rect.bottom < 0 || rect.top - viewHeight >= 0);
}



var toastMessageEl = document.getElementById('toastMessage');
var showToast = async(content)=>
{
  console.log("showToast()",content);
  toastMessageEl.innerHTML = content;
  toastMessageEl.classList.remove('hidden');
  await wait(0);
  toastMessageEl.classList.add('showing');
  await wait(2000);
  toastMessageEl.classList.add('hidding');
  await wait(302);
  toastMessageEl.classList.add('hidden');
  await wait(0);
  toastMessageEl.classList.remove('hidding');
  toastMessageEl.classList.remove('showing');
}






var claimsDB;
async function openClaimsDB()
{
  claimsDB = await idb.openDB("claims", 1, {
    upgrade(db, oldVersion, newVersion, transaction) {
      db.createObjectStore('claims', { keyPath: 'id' });
    },
  });

}


var persistedCount = 0;
var persistedDeletedCount = 0;
function reportPersistedNow()
{
  console.log("reportPersistedNow()","persisted",persistedCount,"claims","and removed",persistedDeletedCount,"claims");
  persistedCount = 0;
  persistedDeletedCount = 0;
}
var reportPersistedDebounced = _.throttle(reportPersistedNow,5000);
function reportPersisted(remove=false)
{
  if(remove) persistedDeletedCount++;
  else persistedCount++;
  reportPersistedDebounced();
}

async function persistClaim(claim,remove=false)
{
  if(remove)
  {
    var response = await claimsDB.delete('claims', claim.id);
    // console.log('persistClaim() deleted','response',response);
  }
  else
  {
    var claimJson = claim.toCompactJson();
    claimJson.id = claim.id;
    await claimsDB.put('claims', claimJson);
  }
  reportPersisted(remove);
  // console.log("persistClaim()","claim",claim.id,claim.idStr,"persisted");
}

// Claim.onNewClaim = persistClaim;
var _skipPersistLocal = false;
var _skipPersistServer = false;
Claim.onNewClaim = (claim,remove=false)=>
{
  // if(!_skipPersistLocal && !remove) console.log("Claim.onNewClaim()","claim",claim.id,claim.idStr,"persistClaim()");
  if(!_skipPersistLocal) persistClaim(claim,remove);
  if(remove) return;
  // if(!_skipPersistServer) console.log("Claim.onNewClaim()","claim",claim.id,claim.idStr,"sendClaimToServer()");
  if(!_skipPersistServer) sendClaimToServer(claim);
};

async function loadClaimsForDB()
{
  _skipPersistServer = true;
  _skipPersistLocal = true;
  console.log("loadClaimsForDB()","_skipPersistLocal",_skipPersistLocal);
  var claimJsons = await claimsDB.getAll('claims')
  for(var claimJson of claimJsons)
    var claim = Claim.fromCompactJson(claimJson);
  _skipPersistLocal = false;
  _skipPersistServer = false;
  console.log("loadClaimsForDB()","_skipPersistLocal",_skipPersistLocal);
}







async function importData(jsonPath)
{
  _skipPersistServer = true;
  var fetched = await fetch(jsonPath);
  var json = await fetched.json();
  importClaims(json.compactJson);
  _skipPersistServer = false;

}




var loggedUser;
var socket;
var _wsRequestPromises = {};
var connectToWebsocket = ()=>
{
  socket = new WebSocket('ws://localhost:8080');
  // Connection opened
  socket.addEventListener('open', function (event)
  {
  });
  socket.addEventListener('close', async function (event)
  {
    // alert("WebSocket closed.");
    await wait(1000);
    connectToWebsocket();
  });

  socket.addEventListener('message', function (event)
  {
    // console.log('Message from server ', event.data);
    var json = JSON.parse(event.data);
    _wsRequestPromises[json.requestId].resolve(json);
  });
}
connectToWebsocket();


async function wsFetch(request)
{
  if(_claimsToServerStore)
  {
    _sendClaimsToServerDebounced.cancel();
    if(!request.claims)
    {
      var claimsRequest = _sendClaimsToServerNow(true);
      request.claims = claimsRequest.claims;
    }
    else _sendClaimsToServerNow();
  }

  request.requestId = randHex();
  var promise = resolvablePromise();
  _wsRequestPromises[request.requestId] = promise;
  socket.send(JSON.stringify(request));
  var response = await promise;
  _skipPersistServer = true;
  if(response.claims) importClaims(response.claims);
  _skipPersistServer = false;
  delete _wsRequestPromises[request.requestId];
  return response;
}




var _claimsToServerStore;
function _sendClaimsToServerNow(_getRequestNotSent=false)
{
  console.log("sendClaimsToServerNow()","claim count",_claimsToServerStore.length);
  var compactJson = _claimsToServerStore.toCompactJson();
  _claimsToServerStore = null;
  var request = {claims:compactJson};
  if(_getRequestNotSent) return request;
  wsFetch(request); // ignore the answer, assumes it went through
}
_sendClaimsToServerDebounced = _.debounce(_sendClaimsToServerNow,500,{maxWait:3000});

function sendClaimToServer(claim)
{
  if(!_claimsToServerStore) _claimsToServerStore = new ClaimStore();
  _claimsToServerStore.addClaim(claim);
  _sendClaimsToServerDebounced();
}


async function fectchComplementaryNodesFromServer(nodes)
{
  var unknownNodes = [];
  nodes.forEach(node=>
  {
    var types = node.getFrom_types();
    types.forEach(type=>
    {
      if(!type.$(_instanceOf)) unknownNodes.push(type);
      node.typeTos[type.id].forEach(claim=>
      {
        var to = claim.to;
        if(to instanceof Node && !to.$(_instanceOf)) unknownNodes.push(to);
      });
    });
  });
  if(unknownNodes.length > 0) console.log("fectchComplementaryNodesFromServer() …",'count',nodes.length,'unknownCount',unknownNodes.length);
  if(unknownNodes.length > 0) await fetchNodesFromServer(unknownNodes);
}

async function fetchNodesFromServer(nodes)
{
  await wsFetch({request:"fetchNodesById",nodeIds:nodes.map(n=>n.id)});
  console.log("fetchNodesByIdFromServer() done. Nodes: ",nodes.map(n=>n.$('prettyString')));
  await fectchComplementaryNodesFromServer(nodes);
}
async function deleteNodesFromServer(nodes)
{
  await wsFetch({request:"deleteNodesById",nodeIds:nodes.map(n=>n.id)});
  console.log("deleteNodesFromServer() done. Nodes: ",nodes.map(n=>n.$('prettyString')));
}

// async function fetchCollectionFromServer(collection,skip=0,limit=10)
// {
//   var {results,totalCount} = await wsFetch({request:"fetchCollection",collection:$$(collection).id,skip,limit});
//   results = results.map(id=>Node.makeById(id));
//   await fectchComplementaryNodesFromServer(results);
//   return {results,totalCount};
// }


async function serverFetchCollection(collection,skip=0,limit=10,localIds=[])
{
  console.log("serverFetchCollection()",skip.from ? 'from: '+skip.from.$('prettyString') : skip,limit);

  // TODO make sure that the server has skip.from (send proactively if in doubt, just in case,
  // or if unlikely, leave it ask for it if needed).
  if(skip.from) skip.from = skip.from.id;
  // results contains only nodes not in localIds
  var {results,totalCount} = await wsFetch({request:"fetchCollection",collection:$$(collection).id,skip,limit,localIds});
  results = results.map(id=>Node.makeById(id));
  await fectchComplementaryNodesFromServer(results);
  return {results,totalCount};
}
















// async function onHeaderSearch()
// {
//   var input = document.getElementById('headerSearch').value;
//   var youtubeVideoUrlRegex = /https:\/\/www.youtube.com\/watch\?v=([a-zA-Z0-9\-]+)/;
//   var youtubeVideoUrlMatch = input.match(youtubeVideoUrlRegex);
//   if(youtubeVideoUrlMatch)
//   {
//     var vid = youtubeVideoUrlMatch[1];
//     // var response = await wsFetch({multiple:false,descriptor:[["instanceOf","YoutubeVideo"],["strid",vid]]});
//     var response = await wsFetch({request:"makeYouTubeVideo",vid});
//     goToObject(response.videoId);
//   }
//   document.getElementById('headerSearch').value = '';
// }
var searchResultsContainer = document.getElementById('searchResultsContainer');
var searchInput = document.getElementById('headerSearch');
var lastFullTextSearchCollection;
var lastFullTextSearchDate = 0;
var waitingUnpureTextSearch = false;
function onHeaderSearchChanged(_waitingUnpureTextSearch)
{
  if(_waitingUnpureTextSearch == false) waitingUnpureTextSearch = false;
  if(_waitingUnpureTextSearch == true ) waitingUnpureTextSearch = true;
  if(searchInput.value.length < 3) return removeUnpureTextSearch();

  var unpure = currentlyUnpureTextSearching();
  if(waitingUnpureTextSearch && !unpure)
    if(startUnpureTextSearch()) return;
  if(waitingUnpureTextSearch && unpure)
    if(updateTextSearch()) return; // should always return

  startPureTextSearch();
}

function removeUnpureTextSearch()
{
  var unpureSearched = currentlyUnpureTextSearching();
  if(!unpureSearched) return false;
  var collection = unpureSearched.$('collection');
  pushTextSearchCollection(collection);
  return true;
}

// function currentlyPureTextSearching()
// {
//   if(selectedInstanciable != $$('collection')) return false;
//   var descriptor = selectedNode.$('descriptor');
//   if(descriptor.$('instanceOf') != $$('descriptorFullTextSearch')) return false;
//   return true;
// }
function currentlyUnpureTextSearching()
{
  if(selectedInstanciable != $$('collection')) return false;
  var descriptor = selectedNode.$('descriptor');
  if(descriptor.$('instanceOf') != $$('descriptorIntersection')) return false;
  var inOrdered = descriptor.$('inOrdered');
  if(inOrdered.$('instanceOf') != $$('descriptorFullTextSearch')) return false;
  var ins = descriptor.$('in');
  if(ins.length != 1) return false;
  return ins[0];
}

function pushTextSearchCollection(collection)
{
  goToObject(collection,undefined,
    // skip pushing to history (update instead) if previous
    // view was a search and less than 3 sec has passed
    selectedNode==lastFullTextSearchCollection
    && Date.now()-lastFullTextSearchDate < 3000);
  lastFullTextSearchCollection = collection;
  lastFullTextSearchDate = Date.now();
}

function startPureTextSearch()
{
  console.log("startPureTextSearch()");
  var descriptor = makeUnique([
    ['object.instanceOf','descriptorFullTextSearch'],
    ['descriptorFullTextSearch.input',{s:searchInput.value}],
  ]);
  collection = descriptor.$('collection');
  pushTextSearchCollection(collection);
}

function startUnpureTextSearch()
{
  console.log("startUnpureTextSearch() ?");
  if(selectedInstanciable != $$('collection')) return false; // can't
  var descriptor = selectedNode.$('descriptor');
  var ins;
  // if(descriptor.$('instanceOf') == $$('descriptorIntersection'))
  // {
  //   var ins = descriptor.$('in');
  //   var inOrdered = descriptor.$('inOrdered');
  //   if(inOrdered) ins.push(inOrdered);
  // }
  // else ins = [descriptor];
  ins = [descriptor];

  var descriptorFT = makeUnique([
    ['object.instanceOf','descriptorFullTextSearch'],
    ['descriptorFullTextSearch.input',{s:searchInput.value}],
  ]);
  var descriptorInsUnique = [
    ['object.instanceOf','descriptorIntersection'],
    ['descriptorIntersection.inOrdered',descriptorFT],
  ];
  ins.forEach(_in=> descriptorInsUnique.push(['descriptorIntersection.in',_in]) );
  var descriptorIns = makeUnique(descriptorInsUnique);
  collection = descriptorIns.$('collection');
  console.log("startUnpureTextSearch()",collection.$('prettyString'));
  pushTextSearchCollection(collection);
  return true;
}

function updateTextSearch()
{
  console.log("updateTextSearch() ?");
  // if(searchInput.value.length < 3) return false;
  if(selectedInstanciable != $$('collection')) return false;

  var wasSearching = false;
  var searchableClaimTypes = [$$('descriptorIntersection.in'),$$('descriptorIntersection.inOrdered'),
    $$('collection.descriptor'),
    $$('descriptorDifference.positive'),$$('descriptorDifference.negative')];
  var collection = selectedNode.$ex('cloneTreeReplacingBy',
    n=>
    {
      if(n.$('instanceOf') != $$('descriptorFullTextSearch')) return n;
      wasSearching = true;
      return makeUnique([
        ['object.instanceOf','descriptorFullTextSearch'],
        ['descriptorFullTextSearch.input',{s:searchInput.value}]]);
    },
    claimType=> searchableClaimTypes.includes(claimType)
  );

  if(!wasSearching) return false;
  pushTextSearchCollection(collection);
  return true;
}

function clearHeaderSearch()
{
  // if(searchInput === document.activeElement)
  var needed = searchResultsContainer.style.visibility == 'visible'
    || searchInput.value != '';

  searchResultsContainer.style.visibility = "hidden";
  searchInput.value = '';
  if(removeUnpureTextSearch()) needed = true;

  return needed;
}



const LinkShortcuts = "0123456789abcdefghijklmnopqrstuvwxyz";
var showingLinkShortcuts = false;
var idToShortcut;
var shortcutToId;
function showLinkShortcuts()
{
  if(showingLinkShortcuts) return;
  // console.log("showLinkShortcuts()");
  var links = [...document.getElementsByClassName('node-link')];
  links = links.filter(link=>link&&isVisible(link));
  var idList = [];
  idToShortcut = {};
  shortcutToId = {};
  links.forEach(link=>
  {
    var id = link.dataset.id;
    var shortcut = idToShortcut[id];
    if(!shortcut)
    {
      shortcut = idToShortcut[id] = LinkShortcuts[idList.length];
      if(shortcut) shortcutToId[shortcut] = id;
      idList.push(id);
    }
    // console.log("showLinkShortcuts()","link",link.dataset.id,Node.makeById(link.dataset.id).$('prettyString'));

    if(shortcut) link.appendChild(htmlToElement('<span class="node-link-shortcut">'+shortcut+'</span>'));
  });
  showingLinkShortcuts = true;
}
function hideLinkShortcuts()
{
  [...document.getElementsByClassName('node-link-shortcut')].forEach(e=>e.remove());
  showingLinkShortcuts = false;
}
function refreshLinkShortcutsNow()
{
  if(!showingLinkShortcuts) return;
  hideLinkShortcuts();
  showLinkShortcuts();
}
// var refreshLinkShortcutsThrottled = _.throttle(refreshLinkShortcutsNow,50);
var refreshLinkShortcutsThrottled = refreshLinkShortcutsNow;




document.addEventListener('keydown', async e => {
  
  var c = e.ctrlKey;
  var s = e.shiftKey;
  var inputHasFocus = searchInput === document.activeElement;


  // console.log('keydown',!!c,!!s,e.key);

  if(!c&&!s&& showingLinkShortcuts && shortcutToId[e.key])
  {
    var id = shortcutToId[e.key];
    hideLinkShortcuts();
    showObject(Node.makeById(id));
    return e.preventDefault();
  }



  if(!c&&!s&& e.key == 'Enter' && inputHasFocus)
  {
    console.log('Enter while in searchInput');
    clearHeaderSearch();
    if (document.activeElement)
        document.activeElement.blur();
    showLinkShortcuts();
    var id = shortcutToId['0'];
    if(id) showObject(Node.makeById(id));
    else hideLinkShortcuts();
    e.preventDefault();
    e.stopPropagation();
    return;
  }



  if(!c&&!s&& e.key == 'Escape')
  {
    if(selectedMethod == 'resolvablesView')
      goToObject(selectedNode);
    else if(myCodeMirror.hasFocus() && myCodeMirrorFloating)
    {
      console.log("escaping editor…","myCodeMirrorUnsaved",myCodeMirrorUnsaved);
      if(!myCodeMirrorUnsaved || confirm("There are unsaved change. Exit editor anyway?"))
        myCodeMirrorElStyle.visibility = "hidden";
    }
    else if(inputHasFocus || myCodeMirror.hasFocus())
    {
      // Give the document focus
      window.focus();

      // Remove focus from any focused element
      if (document.activeElement)
          document.activeElement.blur();
    }
    else if(showingLinkShortcuts) hideLinkShortcuts();
    else clearHeaderSearch();

    return e.preventDefault();
  }


  // console.log("keydown",e.key,e.ctrlKey);
  if(!c&&!s&& e.key == 'Enter' && !myCodeMirrorFloating && !myCodeMirror.hasFocus() && !inputHasFocus)
  {
    myCodeMirror.focus();
    return e.preventDefault();
  }
  if(myCodeMirror.hasFocus())
  {
    if( c&&!s&& (e.key == 's' || e.key == 't'))
    {
      console.log("saving…");
      saveEditJs();
      myCodeMirrorUnsaved = false;
      if(e.key == 't') myCodeMirrorElStyle.visibility = "hidden";
      return e.preventDefault();
    }
  }
  else
  if(!inputHasFocus)
  {
    if( c&& s&& e.key == 'e' && myCodeMirrorFloating)
    {
      myCodeMirrorElStyle.visibility = "visible";
      return e.preventDefault();
    }



    // if(e.ctrlKey)
    // {
    //   var pos = CollectionShortcuts.indexOf(e.key);
    //   var collection = document.getElementsByClassName('collection-items')[0];
    //   console.log("shift+shortcut",e.key,pos,collection);
    //   if(pos != -1 && collection)
    //   {
    //     var child = collection.children[pos]; // should search by data-shortcut attribute
    //     console.log("shift+shortcut",pos,collection,child);
    //     if(child)
    //     {
    //       var node = $$(child.dataset.node);
    //       showObject(node);
    //       return e.preventDefault();
    //     }
    //   }
    // }
  }



  if(myCodeMirror.hasFocus())
    return;
  if(inputHasFocus)
    return;



  var shortcutsEls = [...document.getElementsByClassName("dom-shortcut")];
  var shortcuts = {};
  shortcutsEls.map(el=> console.log(el.dataset.shortcut,el.dataset.nodeId,el.dataset) );
  shortcutsEls.map(el=> shortcuts[el.dataset.shortcut] = Node.makeById(el.dataset.nodeId) );
  if(selectedMethod == 'resolvablesView' && shortcuts[e.key])
  {
    goToObject(shortcuts[e.key]);
    return;
  }



  if(!c&&!s&& e.key == ' ')
  {
    if(showingLinkShortcuts) hideLinkShortcuts();
    else showLinkShortcuts();
    return e.preventDefault();
  }

  if(!c&&!s&& e.key == 'p')
  {
    if(selectedInstanciable == $$('claimType'))
      goToObject(selectedNode.$('typeFrom'));
    return e.preventDefault();
  }

  if(!c&&!s&& (e.key == 'a' || e.key == 'ArrowLeft'))
  {
    window.history.back();
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'e')
  {
    window.history.forward();
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'd')
  {
    if(!confirm('Are you sure?')) return;
    selectedNode.delete();
    deleteNodesFromServer([selectedNode]);
    window.history.back();
    e.stopPropagation();
    return e.preventDefault();
  }


  if(!c&&!s&& e.key == 'v')
  {
    var defaultMethod = selectedNode.$ex('object.defaultPageView');
    if(selectedMethod != defaultMethod)
      goToObject(selectedNode);
    else if(selectedMethod != 'simpleView')
      goToObject(selectedNode,'simpleView');
      // window.location.hash = selectedNode.name+'/simpleView';
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'i')
  {
    var instanciable = selectedNode.$('instanceOf');
    if(instanciable) goToObject(instanciable);
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'b')
  {
    addToClipboard();
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'g')
  {
    // goToObject(_.last(loggedUser.$('clipboard')));
    goToObject(_.first(Node.makeById('93a8def8').$('resolve')));
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'k')
  {
    goToObject(_kaielvin);
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'f')
  {
    searchInput.focus();
    searchInput.value = '';
    onHeaderSearchChanged(false);
    return e.preventDefault();
  }
  if(!c&& s&& e.key == 'F')
  {
    goToObject(_instanciable.$('collection'));
    searchInput.focus();
    searchInput.value = '';
    onHeaderSearchChanged(true);
    return e.preventDefault();
  }
  if( c&&!s&& e.key == 'f')
  {
    searchInput.focus();
    searchInput.value = '';
    onHeaderSearchChanged(true);
    return e.preventDefault();
  }

  if(!c&&!s&& e.key == 'z')
  {
    // TESTTEST
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'ArrowUp')
  {
    if(selectedInstanciable == $$('accessorTo')   || selectedInstanciable == $$('descriptorTo')
    || selectedInstanciable == $$('accessorFrom') || selectedInstanciable == $$('descriptorFrom'))
      goToObject(selectedNode.$('type') || selectedNode.$('types'));
    if(selectedInstanciable == $$('claimType'))
      goToObject(selectedNode.$('typeFrom'));
    if(selectedInstanciable == $$('descriptorDifference'))
      goToObject(selectedNode.$('positive'));
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'ArrowRight')
  {
    if(selectedInstanciable == $$('collection'))
      goToObject(selectedNode.$('descriptor'));
    if(selectedInstanciable == $$('accessorTo') || selectedInstanciable == $$('accessorFrom')
      || selectedInstanciable == $$('uniqueBy') || selectedInstanciable == $$('sort'))
      goToObject(selectedNode.$('in') || selectedNode.$('ins'));
    if(selectedInstanciable == $$('descriptorFrom'))
      goToObject(selectedNode.$('to') || selectedNode.$('tos'));
    if(selectedInstanciable == $$('claimType'))
      goToObject(selectedNode.$('typeTo'));
    if(selectedInstanciable == $$('descriptorDifference'))
      goToObject(selectedNode.$('negative'));
    if(selectedInstanciable == $$('descriptorTo'))
      goToObject(selectedNode.$('from') || selectedNode.$('froms'));

    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'n')
  {
    if(selectedInstanciable == _instanciable)
    {
      var newInstanceDesc = makeUnique([
        [_instanceOf,'descriptorFrom'],
        ['descriptorFrom.type',_instanceOf],
        ['descriptorFrom.to',selectedNode],
      ]);
      createInDescriptor(newInstanceDesc);
    }
    return e.preventDefault();
  }
  if(!c&&!s&& e.key == 'r')
  {
    e.preventDefault();
    await fetchNodesFromServer([selectedNode]);
    showObject(selectedNode);
    return;
  }
  // if(!c&&!s&& e.key == 'ê')
  if(!c&&!s&& e.key == 'à')
  {
    goToObject(selectedNode,selectedMethod == 'resolvablesView' ? undefined : 'resolvablesView');
    e.preventDefault();
    return;
  }

  if(!c&&!s&& e.key == 'c')
  {
    if(selectedNode.$('instanceOf') == $$('collection'))
    {
      var mainContainingNode = selectedNode.$('mainContainingNode');
      if(mainContainingNode) goToObject(mainContainingNode);
    }
    else
    {
      var collection = selectedNode.$('collection');
      if(collection) goToObject(collection);
    }
    return e.preventDefault();
  }

  var menu = document.getElementsByClassName("menu")[0];
  // console.log(menu instanceof Element);
  // console.log(menu);
  var options = menu && menu.getElementsByClassName("option");
  options = options && Array.prototype.slice.call(options) || [];
  // console.log(options);

  options = options && options.map(option=>
    {
      var links = option.getElementsByTagName('a');
      var link = links && links[0];
      // console.log(link);
      // console.log(link.href);
      return link && link.href;
    });

  if(!c&&!s&& e.key == '.')               return location.hash = "kaisHome";
  if(!c&&!s&& e.key == '0' && options[0]) return window.location.href = options[0];
  // else if(e.key == '0')          location.hash = "kaisHome";
  // if(e.key == '0'              ) location.hash = "kaisHome";
  // if(e.key == '9' && options[0]) location.hash = options[0].substring(1);
  // if(e.key == '6' && options[1]) location.hash = options[1].substring(1);
  // if(e.key == '3' && options[2]) location.hash = options[2].substring(1);
  if(!c&&!s&& e.key == '1' && options[1]) return window.location.href = options[1];
  if(!c&&!s&& e.key == '2' && options[2]) return window.location.href = options[2];
  if(!c&&!s&& e.key == '3' && options[3]) return window.location.href = options[3];

  var digit =  e.key.charCodeAt() >= '0'.charCodeAt() && e.key.charCodeAt() <= '9'.charCodeAt();
  if(!c&&!s&& digit)
  {
    var i = e.key.charCodeAt() - '0'.charCodeAt();
    var clipboard = Node.makeById('93a8def8').$('resolve');
    goToObject(clipboard[i]);
    return;
  }

});



document.addEventListener('keyup', (e) => {
  
  var c = e.ctrlKey;
  var s = e.shiftKey;



  // console.log("keyup",e.key,e.ctrlKey);
  if(myCodeMirror.hasFocus())
    return;
  if(searchInput == document.activeElement)
    return;
});




document.addEventListener("click", async e=>
{
  var aEl = findParent('a',e.target || e.srcElement);
  if (!aEl) return;
  var url = aEl.href;
  var hash = url.split('#');
  if(hash.length == 0) return;
  hash = _.last(hash);
  if(hash.includes('/')) return; // TODO, maybe
  var node = $$(hash);
  if(!node) console.error("on click,","unknown node",hash);
  if(!node) return;
  if(e.shiftKey)
  {
    addToClipboard(node);
    e.preventDefault();
    e.stopPropagation();
    clearHeaderSearch();
    return;
  }

  if(selectedMethod != 'simpleView'
    || searchResultsContainer.style.visibility == "visible")
  {
    var instanciable = node.$('instanceOf');
    if(instanciable && instanciable == $$('tag'))
    {
      var descriptor = makeUnique([
          ['object.instanceOf','descriptorFrom'],
          ['descriptorFrom.to',node],
          ['descriptorFrom.type','object.tags'],
        ])
      var collection = makeUnique([
          ['object.instanceOf','collection'],
          ['collection.descriptor',descriptor],
        ])
      e.preventDefault();
      e.stopPropagation();
      goToObject(collection);
    }
    if(instanciable && instanciable == $$('YoutubeChannel'))
    {
      var descriptor = makeUnique([
          ['object.instanceOf','descriptorFrom'],
          ['descriptorFrom.to',node],
          ['descriptorFrom.type','YoutubeVideo.channel'],
        ])
      var collection = makeUnique([
          ['object.instanceOf','collection'],
          ['collection.descriptor',descriptor],
        ])
      e.preventDefault();
      e.stopPropagation();
      goToObject(collection);
    }
  }
  console.log("clicked",url);
});

// content.appendChild(_instanciable.executeJsMethod($$('simpleView')));





























var viewport = ()=>
{
  if(window.visualViewport) return window.visualViewport;
  return {width:window.innerWidth,height:window.innerHeight};
}

window.onscroll = function()
{

  if(showingLinkShortcuts) refreshLinkShortcutsThrottled();
  var contentBox = document.body.getBoundingClientRect()
  var bottomPos = document.body.scrollTop+viewport().height;
  // console.log(document.body.scrollTop,contentBox.height,viewport().height,bottomPos>contentBox.height-500);
  if(bottomPos>contentBox.height-500 && !loadingPagination)
    pageCollection();
};




function addToClipboard(node)
{
  if(!node) node = selectedNode;
  loggedUser.$('clipboard',node);
  showToast("clipboarded "+node.$('prettyString'));
}

var collectionPagingInfo;
var loadingPagination = false;
async function pageCollection()
{
  loadingPagination = true;
  if(selectedInstanciable != $$('collection') || selectedMethod != 'page')
  {
    collectionPagingInfo = undefined;
    return;
  }
  var node = selectedNode;

  if(!collectionPagingInfo || collectionPagingInfo.collection != node)
    collectionPagingInfo = {collection:node,skip:0,count:0};
  if(!collectionPagingInfo.reachedEnd)
  {
    var limit = 50;
    var results = await node.$exAsync('fetch',collectionPagingInfo.skip,limit);
    // results.forEach(r=>console.log("pageCollection() PAGING",r.id,r.$('prettyString')));

    // TODO wait that the page is rendered
    var collectionContainer = document.getElementsByClassName('collection-items')[0];
    // console.log('pageCollection()',collectionContainer);
    if(!collectionContainer) console.error("pageCollection()","collectionContainer not found on DOM.");
    else results.forEach(r=>
    {
      // console.log("pageCollection() adding to DOM: ",r.id,r.$('prettyString'));
      collectionContainer.appendChild(htmlToElement(  r.$ex('rowView')  ));
    });

    collectionPagingInfo.count+= results.length;
    if(results.length < limit) console.log("pageCollection() PAGING REACHED END")
    if(results.length < limit) collectionPagingInfo.reachedEnd = true;
    // if(results.length == 0) collectionPagingInfo.reachedEnd = true;
    else collectionPagingInfo.skip = {from:_.last(results)};
    // await showObject(selectedNode,false,true);
  }

  // if(!collectionPagingInfo || collectionPagingInfo.collection != node)
  //   collectionPagingInfo = {collection:node};
  // var c = collectionPagingInfo;
  // if(c.serverTotalCount == undefined || c.serverSkip < c.serverTotalCount)
  // {
  //   var {totalCount,results} = await fetchCollectionFromServer(node,c.serverSkip,50);
  //   c.serverTotalCount = totalCount;
  //   c.serverSkip = (c.serverSkip || 0)+results.length;
  //   console.log('pageCollection',results.map(r=>r.$('prettyString')),c);
  //   // if(c.serverSkip < c.serverTotalCount)
  //   await showObject(selectedNode,false,true);
  // }
  loadingPagination = false;
}
var goToObject = async (node,method=undefined,throttled=false)=>
{
  node = $$(node);
  var hash = node.name;
  var defaultMethod = node.$ex('object.defaultPageView');
  if(!method) method = defaultMethod;
  if(method != defaultMethod)
    hash+= '/'+method;
  if(throttled)
  {
    history.replaceState(null,null,'#'+hash);
    showObject(node);
  }
  else location.hash = hash;
}

var _content = document.getElementById("content");
var selectedNode = _instanciable;
var selectedInstanciable = _instanciable;
var selectedMethod;
var showObject = async (node,updateHash=true,skipFetch=false)=>
{
  // clearHeaderSearch();

  // console.log("showObject()", node instanceof Node ? node.name: JSON.stringify(node));

  // var method = 'object.simpleView';
  selectedMethod = undefined;
  if(!node) node = selectedNode;
  if(_.isString(node)) 
  {
    var split = node.split('/');
    if(split.length >= 2)
    {
      node = split[0];
      selectedMethod = split[1];
    }
    node = resolveIntoNode(node);
  }
  if(!node) node = selectedNode;
  selectedNode = node;
  var hash = node.name;
  var instanciable = node.$('instanceOf');
  selectedInstanciable = instanciable;


  if(!instanciable && !skipFetch)
  {
    await fetchNodesFromServer([node]);
    return showObject(node,true,true);
  }

  // var defaultMethod = instanciable && instanciable.$('defaultPageView') || 'simpleView';
  // var defaultMethod2 = node.$('object.defaultPageView');
  var defaultMethod = node.$ex('object.defaultPageView');
  // if(defaultMethod2 != defaultMethod || defaultMethod3 != defaultMethod)
  //   console.error("showObject()",defaultMethod,defaultMethod2,defaultMethod3);
  if(!selectedMethod) selectedMethod = defaultMethod;
  if(selectedMethod != defaultMethod)
    hash+= '/'+selectedMethod;
  if(updateHash) location.hash = hash;
  var methodObject = strToType(selectedMethod,node);
  var html = methodObject && await node.$ex(methodObject);
  console.log("showObject()","LOAD",node.name,selectedMethod,'#'+hash,
    // "instanciable",instanciable&&instanciable.name,
    // 'defaultMethod2',defaultMethod2,
    "method",methodObject&&methodObject.name);
  // console.log("showObject()","LOAD",html);
  _content.innerHTML = '';

  // if(!method.includes('.')) method = '.'+method;
  // _content.appendChild(htmlToElement(  await Promise.resolve( $$(node,method) )  ));
  document.title = node.$('prettyString')+(instanciable?' • '+instanciable.$('prettyString'):'')+' • Public';
  _content.appendChild(htmlToElement(  html  ));
  // if(!paginating)
  {
    // should trigger pageCollection()
    if(document.body.scrollTop != 0) window.scrollTo({top:0});
    else pageCollection(node);
  }
  // await wait(0);
  // if(!paginating) pageCollection(node);


  // var ftDesc = node.$ex('searchTreeBy',n=> n.$('instanceOf') == $$('descriptorFullTextSearch'));
  // console.log('showObject()',"fulltextSearch descriptor:",ftDesc&&ftDesc.$('prettyString'));

  if(instanciable == $$('claimType') && node.$('functional'))
  {
    var descriptor = makeUnique([
      [_instanceOf,"descriptorTo"],
      ['descriptorTo.from',node],
      ['descriptorTo.type','claimType.resolve'],
    ]);
    console.log('showObject()','Init editor',descriptor.$('prettyString'));
    var value = descriptor.$("resolve");
    var jsStr = value && value.j && String(value.j) || "function()\n{\n  \n}";
    initEditor( node.$('resolve'),'claimTypeCodeEditor',false);
    myCodeMirror.setValue(jsStr);
    myCodeMirrorElStyle.visibility = "visible";
    myCodeMirrorUnsaved = false;
    // myCodeMirror.focus();
    myCodeMirrorDescriptor = descriptor;
  }
}

// var _selectedDescriptor = document.getElementById("selectedDescriptor");
// var selectedDescriptor;
// var updateSelectedDescriptor = descriptor=>
// {
//   console.log("updateSelectedDescriptor()","descriptor",descriptor);
//   _selectedDescriptor.innerHTML = '';
//   _selectedDescriptor.appendChild(htmlToElement($$(descriptor,'object.htmlSmallDescription')));

//   selectedDescriptor = descriptor;
// }
var editStringDescriptor = descriptor=>
{
  // if(!confirm('Are you sure?')) return;
  var value = $$(descriptor,"descriptorTo.resolve");
  var newString = prompt("string value:", value&&value.s);
  if(newString === null) return;
  $$( $$(descriptor,"descriptorTo.from"),$$(descriptor,"descriptorTo.type"),{s:newString} );
  showObjectFromHash();
}
// var editBooleanDescriptor = (descriptor,value)=>
// {
//   console.log("editBooleanDescriptor",descriptor.$('prettyString'),valueToString(value));
//   descriptor.$ex('insert',value);
//   // $$( $$(descriptor,"descriptorTo.from"),$$(descriptor,"descriptorTo.type"),{s:newString} );
//   showObjectFromHash();
// }
var insertIntoDescriptor = (descriptor,value)=>
{
  if(!confirm('Are you sure?')) return;
  console.log("insertIntoDescriptor",descriptor.$('prettyString'),valueToString(value));
  descriptor.$ex('insert',value);
  showObjectFromHash();
}
var editJavascriptDescriptor = descriptor=>
{
  var value = descriptor.$("resolve");
  var jsStr = value && value.j && String(value.j) || "function()\n{\n  \n}";
  console.log('editJavascriptDescriptor()',descriptor.$('prettyString'),jsStr);
  // document.getElementById("codeEditor").innerHTML = jsStr;
  myCodeMirror.setValue(jsStr);
  myCodeMirrorElStyle.visibility = "visible";
  myCodeMirrorUnsaved = false;
  // myCodeMirror.focus();
  myCodeMirrorDescriptor = descriptor;

  // $$( $$(descriptor,"descriptorTo.from"),$$(descriptor,"descriptorTo.type"),{s:newString} );
  // showObjectFromHash();
}

var createField = (type,instanciable)=>
{
  if(!confirm('Are you sure?')) return;
  var claimtype = $$()
    .$('object.instanceOf','claimType')
    .$('claimType.typeFrom',instanciable)
    .$('claimType.typeTo',type);
  console.log("createField",type.$('prettyString'),instanciable.$('prettyString'));
  goToObject(claimtype);
}

var saveEditJs = ()=>
{
  var js;
  try
  {
    js = eval('('+myCodeMirror.getValue()+')');
  }
  catch(e)
  {
    alert('could not compile js');
    console.error('saveEditJs()','could not compile js',e);
    return;
  }
  console.log('saveEditJs()',myCodeMirrorDescriptor.$('prettyString'),String(js));
  myCodeMirrorDescriptor.$ex('insert',{j:js});
}
var createInDescriptor = descriptor=>
{
  if(!confirm('Are you sure?')) return;
  var instance = $$(descriptor,'descriptorFrom.instanciate');
  goToObject(instance);
}

var showObjectFromHash = ()=>showObject(location.hash && location.hash.substring(1) || "instanciable",false);




// async function fetchYoutubePlaylist(playlistId,results=[],pageToken=undefined)
// {
//   console.log("fetchYoutubePlaylist()","pageToken",pageToken);
//   var path = 'https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&key=AIzaSyByA7cXJD_3Hi8f2rTQ3loCyqIA6NfK9fc&playlistId='+playlistId+'&maxResults=50';
//   if(pageToken) path+= '&pageToken='+pageToken;
//   var fetched = await fetch(path);
//   var json = await fetched.json();
//   json.items.forEach(item=>
//   {
//     var vid = item.snippet.resourceId.videoId;
//     console.log("fetchYoutubePlaylist()","videoId",vid);
//     results.push(vid);
//     $$(vid).$(_instanceOf,"YoutubeVideo").$('YoutubeVideo.title',{s:item.snippet.title});
//   });
//   if(json.nextPageToken) await fetchYoutubePlaylist(playlistId,results,json.nextPageToken);
//   return results;
//   // console.log("json",json);
// }
// async function fetchYoutubePlaylists(channelId,results=[],pageToken=undefined)
// {
//   console.log("fetchYoutubePlaylists()","pageToken",pageToken);
//   var path = 'https://www.googleapis.com/youtube/v3/playlists?part=snippet&key=AIzaSyByA7cXJD_3Hi8f2rTQ3loCyqIA6NfK9fc&channelId='+channelId+'&maxResults=50';
//   if(pageToken) path+= '&pageToken='+pageToken;
//   var fetched = await fetch(path);
//   var json = await fetched.json();
//   json.items.forEach(item=>
//   {
//     var pid = item.id;
//     console.log("fetchYoutubePlaylists()","playlistId",pid);
//     results.push(pid);
//     $$(pid).$(_instanceOf,"YoutubePlaylist").$('YoutubePlaylist.title',{s:item.snippet.title});
//   });
//   if(json.nextPageToken) await fetchYoutubePlaylists(channelId,results,json.nextPageToken);
//   return results;
//   // console.log("json",json);
// }

// async function fetchYoutubeData(vid='IK7nBOLYzdE')
// {
//   var path = 'https://cors-anywhere.herokuapp.com/https://www.youtube.com/watch?v='+vid;
//   var fetched = await fetch(path);

//   var text = await fetched.text();
//   var match = text.match(/window\[\"ytInitialPlayerResponse\"\] = (.*)/);
//   if(!match) throw new Error('no json information found');

//   var json = match[1];
//   json = json.substring(0,json.length-1); // removes end ';'
//   json = JSON.parse(json);

//   // console.log('FOUND',json);
//   // console.log('FOUND',JSON.stringify(json,null,'    '));

//   var videoDetails = json.videoDetails;
//   var microformat = json.microformat;
//   var playerMicroformatRenderer = microformat.playerMicroformatRenderer;

//   var processedJson = {};
//   processedJson.fetchDate = new Date();
//   processedJson.title = videoDetails.title;
//   processedJson.lengthSeconds = Number(videoDetails.lengthSeconds);
//   processedJson.averageRating = videoDetails.averageRating;
//   processedJson.viewCount = Number(videoDetails.viewCount);
//   processedJson.publishDate = new Date(playerMicroformatRenderer.publishDate);
//   processedJson.uploadDate = new Date(playerMicroformatRenderer.uploadDate);
//   processedJson.description = playerMicroformatRenderer.description.simpleText;
//   processedJson.keywords = videoDetails.keywords;
//   processedJson.channelId = videoDetails.channelId;
//   processedJson.author = videoDetails.author;
//   processedJson.ownerChannelName = playerMicroformatRenderer.ownerChannelName;

//   var result = {};
//   result.sourceHtml = text;
//   result.extractedJson = json;
//   result.processedJson = processedJson;

//   return result;
// }



(async ()=>
{
  await openClaimsDB();
  await loadClaimsForDB();
  // var fetched = await fetch('https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=PLfoEg9YVcQQS14MaRPjRdYM_Y-HwoQFPJ&key=AIzaSyByA7cXJD_3Hi8f2rTQ3loCyqIA6NfK9fc&pageToken=CAUQAQ&maxResults=5');
  // var json = await fetched.json();
  // console.log("json",json);

  console.log("Claims loaded from local indexedDB.");

  // in the background
  // importData('http://localhost:3000/all');
  // TODO await if db not initiated (can test .count() < 100)
  await importData('http://localhost:3000/all');
  console.log("Claims loaded from server.");


  loggedUser = $$('person').$froms('instanceOf').find(u=>u.$('title') == 'Kai Elvin');
  console.log("loggedUser",loggedUser&&loggedUser.$('title'));

  var _garbageCollect = ()=>garbageCollect([$$('YoutubeVideo'),$$('YoutubeChannel'),$$('watching')]);
  // setInterval(_garbageCollect, 10000);
  // _garbageCollect();

  // var playlist = await fetchYoutubePlaylists('UCDDe2Yh15Yj4ljU_2f311mQ');
  // fetchYoutubePlaylist('PLfoEg9YVcQQS14MaRPjRdYM_Y-HwoQFPJ');

  window.addEventListener("hashchange", showObjectFromHash);
  showObjectFromHash();

  // var request = indexedDB.open("library");

  // fetchYoutubeData('xWggTb45brM');
  // const items = await indexedDB.transaction('testStore').objectStore('testStore').getAll()


  // console.log("UNQIQUEUNIQUSQENEEE",makeUnique([
  //   ['object.instanceOf','descriptorIntersection'],
  //   ['descriptorIntersection.inOrdered',Node.makeById('61c74673')],
  //   ['descriptorIntersection.in',Node.makeById('c13c92bd')],
  // ]).id);
  // console.log(stridToNode('undefined'))


}
)();


var myCodeMirror;
var myCodeMirrorUnsaved;
var myCodeMirrorElStyle
var myCodeMirrorDescriptor;
var myCodeMirrorFloating;
function initEditor(value,id="codeEditor",floating=true)
{
  myCodeMirror = CodeMirror.fromTextArea(document.getElementById(id), {
    value,
    mode:  "javascript",
    extraKeys: {"Ctrl-Space": "autocomplete",
                "Ctrl-/": "toggleComment",
              },
    lineWrapping: true,
    lineNumbers: true,
    // autofocus: true,
    cursorScrollMargin: 2, // doesn't seem to work
    spellcheck: true,
    autocorrect: true,
    theme: "material-darker",
    scrollbarStyle: "overlay",
  });

  myCodeMirrorUnsaved = false;
  myCodeMirror.on('change',()=> myCodeMirrorUnsaved = true);

  myCodeMirrorFloating = floating;
  myCodeMirrorElStyle = myCodeMirror.getWrapperElement().style;
  if(floating)
  {
    myCodeMirrorElStyle.visibility = "hidden";
    myCodeMirrorElStyle.position = "fixed";
    myCodeMirrorElStyle.height = "auto";
    myCodeMirrorElStyle.left = "10px";
    myCodeMirrorElStyle.right = "10px";
    myCodeMirrorElStyle.top = "50px";
    myCodeMirrorElStyle.bottom = "50px";
  }
  else
  {
    myCodeMirrorElStyle.height = "60em";
    myCodeMirrorElStyle['margin-bottom'] = "1.5em";
  }
}
initEditor();

</script>


    </body>
</html>